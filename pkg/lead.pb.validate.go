// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: lead.proto

package leadexchangev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// define the regex for a UUID once up-front
var _lead_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on Lead with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Lead) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Lead with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LeadMultiError, or nil if none found.
func (m *Lead) ValidateAll() error {
	return m.validate(true)
}

func (m *Lead) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LeadId

	if utf8.RuneCountInString(m.GetTitle()) < 3 {
		err := LeadValidationError{
			field:  "Title",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Requirement

	if utf8.RuneCountInString(m.GetContactName()) < 2 {
		err := LeadValidationError{
			field:  "ContactName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_Lead_ContactPhone_Pattern.MatchString(m.GetContactPhone()) {
		err := LeadValidationError{
			field:  "ContactPhone",
			reason: "value does not match regex pattern \"^\\\\+?[0-9\\\\s()-]{7,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContactEmail() != "" {

		if err := m._validateEmail(m.GetContactEmail()); err != nil {
			err = LeadValidationError{
				field:  "ContactEmail",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for Status

	if err := m._validateUuid(m.GetOwnerUserId()); err != nil {
		err = LeadValidationError{
			field:  "OwnerUserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if err := m._validateUuid(m.GetCreatedUserId()); err != nil {
		err = LeadValidationError{
			field:  "CreatedUserId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CreatedAt

	// no validation rules for UpdatedAt

	// no validation rules for PropertyType

	if m.City != nil {
		// no validation rules for City
	}

	if len(errors) > 0 {
		return LeadMultiError(errors)
	}

	return nil
}

func (m *Lead) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Lead) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

func (m *Lead) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// LeadMultiError is an error wrapping multiple validation errors returned by
// Lead.ValidateAll() if the designated constraints aren't met.
type LeadMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeadMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeadMultiError) AllErrors() []error { return m }

// LeadValidationError is the validation error returned by Lead.Validate if the
// designated constraints aren't met.
type LeadValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeadValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeadValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeadValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeadValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeadValidationError) ErrorName() string { return "LeadValidationError" }

// Error satisfies the builtin error interface
func (e LeadValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLead.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeadValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeadValidationError{}

var _Lead_ContactPhone_Pattern = regexp.MustCompile("^\\+?[0-9\\s()-]{7,}$")

// Validate checks the field values on CreateLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateLeadRequestMultiError, or nil if none found.
func (m *CreateLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetTitle()) < 3 {
		err := CreateLeadRequestValidationError{
			field:  "Title",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Description

	// no validation rules for Requirement

	if utf8.RuneCountInString(m.GetContactName()) < 2 {
		err := CreateLeadRequestValidationError{
			field:  "ContactName",
			reason: "value length must be at least 2 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateLeadRequest_ContactPhone_Pattern.MatchString(m.GetContactPhone()) {
		err := CreateLeadRequestValidationError{
			field:  "ContactPhone",
			reason: "value does not match regex pattern \"^\\\\+?[0-9\\\\s()-]{7,}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetContactEmail() != "" {

		if err := m._validateEmail(m.GetContactEmail()); err != nil {
			err = CreateLeadRequestValidationError{
				field:  "ContactEmail",
				reason: "value must be a valid email address",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for PropertyType

	if m.City != nil {
		// no validation rules for City
	}

	if len(errors) > 0 {
		return CreateLeadRequestMultiError(errors)
	}

	return nil
}

func (m *CreateLeadRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *CreateLeadRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// CreateLeadRequestMultiError is an error wrapping multiple validation errors
// returned by CreateLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLeadRequestMultiError) AllErrors() []error { return m }

// CreateLeadRequestValidationError is the validation error returned by
// CreateLeadRequest.Validate if the designated constraints aren't met.
type CreateLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLeadRequestValidationError) ErrorName() string {
	return "CreateLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLeadRequestValidationError{}

var _CreateLeadRequest_ContactPhone_Pattern = regexp.MustCompile("^\\+?[0-9\\s()-]{7,}$")

// Validate checks the field values on GetLeadRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLeadRequestMultiError,
// or nil if none found.
func (m *GetLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = GetLeadRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetLeadRequestMultiError(errors)
	}

	return nil
}

func (m *GetLeadRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetLeadRequestMultiError is an error wrapping multiple validation errors
// returned by GetLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLeadRequestMultiError) AllErrors() []error { return m }

// GetLeadRequestValidationError is the validation error returned by
// GetLeadRequest.Validate if the designated constraints aren't met.
type GetLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLeadRequestValidationError) ErrorName() string { return "GetLeadRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLeadRequestValidationError{}

// Validate checks the field values on ListLeadsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsRequestMultiError, or nil if none found.
func (m *ListLeadsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListLeadsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListLeadsRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListLeadsRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.PageSize != nil {
		// no validation rules for PageSize
	}

	if m.PageToken != nil {
		// no validation rules for PageToken
	}

	if m.OrderBy != nil {
		// no validation rules for OrderBy
	}

	if m.OrderDirection != nil {
		// no validation rules for OrderDirection
	}

	if len(errors) > 0 {
		return ListLeadsRequestMultiError(errors)
	}

	return nil
}

// ListLeadsRequestMultiError is an error wrapping multiple validation errors
// returned by ListLeadsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListLeadsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsRequestMultiError) AllErrors() []error { return m }

// ListLeadsRequestValidationError is the validation error returned by
// ListLeadsRequest.Validate if the designated constraints aren't met.
type ListLeadsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsRequestValidationError) ErrorName() string { return "ListLeadsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListLeadsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsRequestValidationError{}

// Validate checks the field values on ReindexLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReindexLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReindexLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReindexLeadRequestMultiError, or nil if none found.
func (m *ReindexLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ReindexLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = ReindexLeadRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ReindexLeadRequestMultiError(errors)
	}

	return nil
}

func (m *ReindexLeadRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ReindexLeadRequestMultiError is an error wrapping multiple validation errors
// returned by ReindexLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type ReindexLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReindexLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReindexLeadRequestMultiError) AllErrors() []error { return m }

// ReindexLeadRequestValidationError is the validation error returned by
// ReindexLeadRequest.Validate if the designated constraints aren't met.
type ReindexLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReindexLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReindexLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReindexLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReindexLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReindexLeadRequestValidationError) ErrorName() string {
	return "ReindexLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReindexLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReindexLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReindexLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReindexLeadRequestValidationError{}

// Validate checks the field values on ReindexLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReindexLeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReindexLeadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReindexLeadResponseMultiError, or nil if none found.
func (m *ReindexLeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ReindexLeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Message

	if len(errors) > 0 {
		return ReindexLeadResponseMultiError(errors)
	}

	return nil
}

// ReindexLeadResponseMultiError is an error wrapping multiple validation
// errors returned by ReindexLeadResponse.ValidateAll() if the designated
// constraints aren't met.
type ReindexLeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReindexLeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReindexLeadResponseMultiError) AllErrors() []error { return m }

// ReindexLeadResponseValidationError is the validation error returned by
// ReindexLeadResponse.Validate if the designated constraints aren't met.
type ReindexLeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReindexLeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReindexLeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReindexLeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReindexLeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReindexLeadResponseValidationError) ErrorName() string {
	return "ReindexLeadResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ReindexLeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReindexLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReindexLeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReindexLeadResponseValidationError{}

// Validate checks the field values on ListLeadsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsResponseMultiError, or nil if none found.
func (m *ListLeadsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLeads() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListLeadsResponseValidationError{
						field:  fmt.Sprintf("Leads[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListLeadsResponseValidationError{
					field:  fmt.Sprintf("Leads[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListLeadsResponseMultiError(errors)
	}

	return nil
}

// ListLeadsResponseMultiError is an error wrapping multiple validation errors
// returned by ListLeadsResponse.ValidateAll() if the designated constraints
// aren't met.
type ListLeadsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsResponseMultiError) AllErrors() []error { return m }

// ListLeadsResponseValidationError is the validation error returned by
// ListLeadsResponse.Validate if the designated constraints aren't met.
type ListLeadsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsResponseValidationError) ErrorName() string {
	return "ListLeadsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeadsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsResponseValidationError{}

// Validate checks the field values on UpdateLeadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateLeadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateLeadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateLeadRequestMultiError, or nil if none found.
func (m *UpdateLeadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateLeadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = UpdateLeadRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Title != nil {
		// no validation rules for Title
	}

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Requirement != nil {
		// no validation rules for Requirement
	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.OwnerUserId != nil {
		// no validation rules for OwnerUserId
	}

	if m.City != nil {
		// no validation rules for City
	}

	if m.PropertyType != nil {
		// no validation rules for PropertyType
	}

	if len(errors) > 0 {
		return UpdateLeadRequestMultiError(errors)
	}

	return nil
}

func (m *UpdateLeadRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// UpdateLeadRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateLeadRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateLeadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLeadRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLeadRequestMultiError) AllErrors() []error { return m }

// UpdateLeadRequestValidationError is the validation error returned by
// UpdateLeadRequest.Validate if the designated constraints aren't met.
type UpdateLeadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLeadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLeadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLeadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLeadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLeadRequestValidationError) ErrorName() string {
	return "UpdateLeadRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLeadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLeadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLeadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLeadRequestValidationError{}

// Validate checks the field values on LeadResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LeadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LeadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LeadResponseMultiError, or
// nil if none found.
func (m *LeadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *LeadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LeadResponseValidationError{
					field:  "Lead",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LeadResponseValidationError{
				field:  "Lead",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LeadResponseMultiError(errors)
	}

	return nil
}

// LeadResponseMultiError is an error wrapping multiple validation errors
// returned by LeadResponse.ValidateAll() if the designated constraints aren't met.
type LeadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LeadResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LeadResponseMultiError) AllErrors() []error { return m }

// LeadResponseValidationError is the validation error returned by
// LeadResponse.Validate if the designated constraints aren't met.
type LeadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LeadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LeadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LeadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LeadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LeadResponseValidationError) ErrorName() string { return "LeadResponseValidationError" }

// Error satisfies the builtin error interface
func (e LeadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLeadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LeadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LeadResponseValidationError{}

// Validate checks the field values on GetClarificationQuestionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetClarificationQuestionsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClarificationQuestionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetClarificationQuestionsRequestMultiError, or nil if none found.
func (m *GetClarificationQuestionsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClarificationQuestionsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = GetClarificationQuestionsRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetClarificationQuestionsRequestMultiError(errors)
	}

	return nil
}

func (m *GetClarificationQuestionsRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// GetClarificationQuestionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetClarificationQuestionsRequest.ValidateAll() if the designated
// constraints aren't met.
type GetClarificationQuestionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClarificationQuestionsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClarificationQuestionsRequestMultiError) AllErrors() []error { return m }

// GetClarificationQuestionsRequestValidationError is the validation error
// returned by GetClarificationQuestionsRequest.Validate if the designated
// constraints aren't met.
type GetClarificationQuestionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClarificationQuestionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClarificationQuestionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClarificationQuestionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClarificationQuestionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClarificationQuestionsRequestValidationError) ErrorName() string {
	return "GetClarificationQuestionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClarificationQuestionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClarificationQuestionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClarificationQuestionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClarificationQuestionsRequestValidationError{}

// Validate checks the field values on ClarificationQuestion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClarificationQuestion) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClarificationQuestion with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClarificationQuestionMultiError, or nil if none found.
func (m *ClarificationQuestion) ValidateAll() error {
	return m.validate(true)
}

func (m *ClarificationQuestion) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for Question

	// no validation rules for QuestionType

	// no validation rules for Importance

	if len(errors) > 0 {
		return ClarificationQuestionMultiError(errors)
	}

	return nil
}

// ClarificationQuestionMultiError is an error wrapping multiple validation
// errors returned by ClarificationQuestion.ValidateAll() if the designated
// constraints aren't met.
type ClarificationQuestionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClarificationQuestionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClarificationQuestionMultiError) AllErrors() []error { return m }

// ClarificationQuestionValidationError is the validation error returned by
// ClarificationQuestion.Validate if the designated constraints aren't met.
type ClarificationQuestionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClarificationQuestionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClarificationQuestionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClarificationQuestionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClarificationQuestionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClarificationQuestionValidationError) ErrorName() string {
	return "ClarificationQuestionValidationError"
}

// Error satisfies the builtin error interface
func (e ClarificationQuestionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClarificationQuestion.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClarificationQuestionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClarificationQuestionValidationError{}

// Validate checks the field values on GetClarificationQuestionsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetClarificationQuestionsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClarificationQuestionsResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetClarificationQuestionsResponseMultiError, or nil if none found.
func (m *GetClarificationQuestionsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClarificationQuestionsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NeedsClarification

	for idx, item := range m.GetQuestions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetClarificationQuestionsResponseValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetClarificationQuestionsResponseValidationError{
						field:  fmt.Sprintf("Questions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetClarificationQuestionsResponseValidationError{
					field:  fmt.Sprintf("Questions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Priority

	// no validation rules for LeadQualityScore

	if len(errors) > 0 {
		return GetClarificationQuestionsResponseMultiError(errors)
	}

	return nil
}

// GetClarificationQuestionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetClarificationQuestionsResponse.ValidateAll() if the designated
// constraints aren't met.
type GetClarificationQuestionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClarificationQuestionsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClarificationQuestionsResponseMultiError) AllErrors() []error { return m }

// GetClarificationQuestionsResponseValidationError is the validation error
// returned by GetClarificationQuestionsResponse.Validate if the designated
// constraints aren't met.
type GetClarificationQuestionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClarificationQuestionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClarificationQuestionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClarificationQuestionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClarificationQuestionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClarificationQuestionsResponseValidationError) ErrorName() string {
	return "GetClarificationQuestionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClarificationQuestionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClarificationQuestionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClarificationQuestionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClarificationQuestionsResponseValidationError{}

// Validate checks the field values on ClarificationAnswer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClarificationAnswer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClarificationAnswer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClarificationAnswerMultiError, or nil if none found.
func (m *ClarificationAnswer) ValidateAll() error {
	return m.validate(true)
}

func (m *ClarificationAnswer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Field

	// no validation rules for Value

	if len(errors) > 0 {
		return ClarificationAnswerMultiError(errors)
	}

	return nil
}

// ClarificationAnswerMultiError is an error wrapping multiple validation
// errors returned by ClarificationAnswer.ValidateAll() if the designated
// constraints aren't met.
type ClarificationAnswerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClarificationAnswerMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClarificationAnswerMultiError) AllErrors() []error { return m }

// ClarificationAnswerValidationError is the validation error returned by
// ClarificationAnswer.Validate if the designated constraints aren't met.
type ClarificationAnswerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClarificationAnswerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClarificationAnswerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClarificationAnswerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClarificationAnswerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClarificationAnswerValidationError) ErrorName() string {
	return "ClarificationAnswerValidationError"
}

// Error satisfies the builtin error interface
func (e ClarificationAnswerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClarificationAnswer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClarificationAnswerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClarificationAnswerValidationError{}

// Validate checks the field values on ApplyClarificationAnswersRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplyClarificationAnswersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyClarificationAnswersRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// ApplyClarificationAnswersRequestMultiError, or nil if none found.
func (m *ApplyClarificationAnswersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyClarificationAnswersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = ApplyClarificationAnswersRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAnswers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApplyClarificationAnswersRequestValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApplyClarificationAnswersRequestValidationError{
						field:  fmt.Sprintf("Answers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApplyClarificationAnswersRequestValidationError{
					field:  fmt.Sprintf("Answers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApplyClarificationAnswersRequestMultiError(errors)
	}

	return nil
}

func (m *ApplyClarificationAnswersRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// ApplyClarificationAnswersRequestMultiError is an error wrapping multiple
// validation errors returned by
// ApplyClarificationAnswersRequest.ValidateAll() if the designated
// constraints aren't met.
type ApplyClarificationAnswersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyClarificationAnswersRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyClarificationAnswersRequestMultiError) AllErrors() []error { return m }

// ApplyClarificationAnswersRequestValidationError is the validation error
// returned by ApplyClarificationAnswersRequest.Validate if the designated
// constraints aren't met.
type ApplyClarificationAnswersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyClarificationAnswersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyClarificationAnswersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyClarificationAnswersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyClarificationAnswersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyClarificationAnswersRequestValidationError) ErrorName() string {
	return "ApplyClarificationAnswersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyClarificationAnswersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyClarificationAnswersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyClarificationAnswersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyClarificationAnswersRequestValidationError{}

// Validate checks the field values on ApplyClarificationAnswersResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ApplyClarificationAnswersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ApplyClarificationAnswersResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ApplyClarificationAnswersResponseMultiError, or nil if none found.
func (m *ApplyClarificationAnswersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ApplyClarificationAnswersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for NewRequirement

	// no validation rules for Message

	if len(errors) > 0 {
		return ApplyClarificationAnswersResponseMultiError(errors)
	}

	return nil
}

// ApplyClarificationAnswersResponseMultiError is an error wrapping multiple
// validation errors returned by
// ApplyClarificationAnswersResponse.ValidateAll() if the designated
// constraints aren't met.
type ApplyClarificationAnswersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApplyClarificationAnswersResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApplyClarificationAnswersResponseMultiError) AllErrors() []error { return m }

// ApplyClarificationAnswersResponseValidationError is the validation error
// returned by ApplyClarificationAnswersResponse.Validate if the designated
// constraints aren't met.
type ApplyClarificationAnswersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApplyClarificationAnswersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApplyClarificationAnswersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApplyClarificationAnswersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApplyClarificationAnswersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApplyClarificationAnswersResponseValidationError) ErrorName() string {
	return "ApplyClarificationAnswersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ApplyClarificationAnswersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApplyClarificationAnswersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApplyClarificationAnswersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApplyClarificationAnswersResponseValidationError{}

// Validate checks the field values on MatchWeights with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MatchWeights) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MatchWeights with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MatchWeightsMultiError, or
// nil if none found.
func (m *MatchWeights) ValidateAll() error {
	return m.validate(true)
}

func (m *MatchWeights) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Price

	// no validation rules for District

	// no validation rules for Rooms

	// no validation rules for Area

	// no validation rules for Semantic

	if len(errors) > 0 {
		return MatchWeightsMultiError(errors)
	}

	return nil
}

// MatchWeightsMultiError is an error wrapping multiple validation errors
// returned by MatchWeights.ValidateAll() if the designated constraints aren't met.
type MatchWeightsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MatchWeightsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MatchWeightsMultiError) AllErrors() []error { return m }

// MatchWeightsValidationError is the validation error returned by
// MatchWeights.Validate if the designated constraints aren't met.
type MatchWeightsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MatchWeightsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MatchWeightsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MatchWeightsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MatchWeightsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MatchWeightsValidationError) ErrorName() string { return "MatchWeightsValidationError" }

// Error satisfies the builtin error interface
func (e MatchWeightsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMatchWeights.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MatchWeightsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MatchWeightsValidationError{}

// Validate checks the field values on ExtractedCriteria with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExtractedCriteria) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExtractedCriteria with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExtractedCriteriaMultiError, or nil if none found.
func (m *ExtractedCriteria) ValidateAll() error {
	return m.validate(true)
}

func (m *ExtractedCriteria) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TargetPrice != nil {
		// no validation rules for TargetPrice
	}

	if m.TargetDistrict != nil {
		// no validation rules for TargetDistrict
	}

	if m.TargetRooms != nil {
		// no validation rules for TargetRooms
	}

	if m.TargetArea != nil {
		// no validation rules for TargetArea
	}

	if len(errors) > 0 {
		return ExtractedCriteriaMultiError(errors)
	}

	return nil
}

// ExtractedCriteriaMultiError is an error wrapping multiple validation errors
// returned by ExtractedCriteria.ValidateAll() if the designated constraints
// aren't met.
type ExtractedCriteriaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExtractedCriteriaMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExtractedCriteriaMultiError) AllErrors() []error { return m }

// ExtractedCriteriaValidationError is the validation error returned by
// ExtractedCriteria.Validate if the designated constraints aren't met.
type ExtractedCriteriaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExtractedCriteriaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExtractedCriteriaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExtractedCriteriaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExtractedCriteriaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExtractedCriteriaValidationError) ErrorName() string {
	return "ExtractedCriteriaValidationError"
}

// Error satisfies the builtin error interface
func (e ExtractedCriteriaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExtractedCriteria.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExtractedCriteriaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExtractedCriteriaValidationError{}

// Validate checks the field values on AnalyzeLeadIntentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeLeadIntentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeLeadIntentRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeLeadIntentRequestMultiError, or nil if none found.
func (m *AnalyzeLeadIntentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeLeadIntentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetLeadId()); err != nil {
		err = AnalyzeLeadIntentRequestValidationError{
			field:  "LeadId",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AnalyzeLeadIntentRequestMultiError(errors)
	}

	return nil
}

func (m *AnalyzeLeadIntentRequest) _validateUuid(uuid string) error {
	if matched := _lead_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// AnalyzeLeadIntentRequestMultiError is an error wrapping multiple validation
// errors returned by AnalyzeLeadIntentRequest.ValidateAll() if the designated
// constraints aren't met.
type AnalyzeLeadIntentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeLeadIntentRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeLeadIntentRequestMultiError) AllErrors() []error { return m }

// AnalyzeLeadIntentRequestValidationError is the validation error returned by
// AnalyzeLeadIntentRequest.Validate if the designated constraints aren't met.
type AnalyzeLeadIntentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeLeadIntentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeLeadIntentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeLeadIntentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeLeadIntentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeLeadIntentRequestValidationError) ErrorName() string {
	return "AnalyzeLeadIntentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeLeadIntentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeLeadIntentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeLeadIntentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeLeadIntentRequestValidationError{}

// Validate checks the field values on AnalyzeLeadIntentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AnalyzeLeadIntentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AnalyzeLeadIntentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AnalyzeLeadIntentResponseMultiError, or nil if none found.
func (m *AnalyzeLeadIntentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AnalyzeLeadIntentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRecommendedWeights()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnalyzeLeadIntentResponseValidationError{
					field:  "RecommendedWeights",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnalyzeLeadIntentResponseValidationError{
					field:  "RecommendedWeights",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRecommendedWeights()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnalyzeLeadIntentResponseValidationError{
				field:  "RecommendedWeights",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetExtractedCriteria()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AnalyzeLeadIntentResponseValidationError{
					field:  "ExtractedCriteria",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AnalyzeLeadIntentResponseValidationError{
					field:  "ExtractedCriteria",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExtractedCriteria()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AnalyzeLeadIntentResponseValidationError{
				field:  "ExtractedCriteria",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LeadType

	// no validation rules for Confidence

	// no validation rules for Explanation

	// no validation rules for UsedLlm

	if len(errors) > 0 {
		return AnalyzeLeadIntentResponseMultiError(errors)
	}

	return nil
}

// AnalyzeLeadIntentResponseMultiError is an error wrapping multiple validation
// errors returned by AnalyzeLeadIntentResponse.ValidateAll() if the
// designated constraints aren't met.
type AnalyzeLeadIntentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnalyzeLeadIntentResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnalyzeLeadIntentResponseMultiError) AllErrors() []error { return m }

// AnalyzeLeadIntentResponseValidationError is the validation error returned by
// AnalyzeLeadIntentResponse.Validate if the designated constraints aren't met.
type AnalyzeLeadIntentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnalyzeLeadIntentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnalyzeLeadIntentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnalyzeLeadIntentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnalyzeLeadIntentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnalyzeLeadIntentResponseValidationError) ErrorName() string {
	return "AnalyzeLeadIntentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AnalyzeLeadIntentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnalyzeLeadIntentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnalyzeLeadIntentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnalyzeLeadIntentResponseValidationError{}

// Validate checks the field values on ListLeadsRequest_Filter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListLeadsRequest_Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListLeadsRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListLeadsRequest_FilterMultiError, or nil if none found.
func (m *ListLeadsRequest_Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListLeadsRequest_Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Status != nil {
		// no validation rules for Status
	}

	if m.OwnerUserId != nil {
		// no validation rules for OwnerUserId
	}

	if m.CreatedUserId != nil {
		// no validation rules for CreatedUserId
	}

	if m.City != nil {
		// no validation rules for City
	}

	if m.PropertyType != nil {
		// no validation rules for PropertyType
	}

	if len(errors) > 0 {
		return ListLeadsRequest_FilterMultiError(errors)
	}

	return nil
}

// ListLeadsRequest_FilterMultiError is an error wrapping multiple validation
// errors returned by ListLeadsRequest_Filter.ValidateAll() if the designated
// constraints aren't met.
type ListLeadsRequest_FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLeadsRequest_FilterMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLeadsRequest_FilterMultiError) AllErrors() []error { return m }

// ListLeadsRequest_FilterValidationError is the validation error returned by
// ListLeadsRequest_Filter.Validate if the designated constraints aren't met.
type ListLeadsRequest_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLeadsRequest_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLeadsRequest_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLeadsRequest_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLeadsRequest_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLeadsRequest_FilterValidationError) ErrorName() string {
	return "ListLeadsRequest_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListLeadsRequest_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLeadsRequest_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLeadsRequest_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLeadsRequest_FilterValidationError{}
